options:
  parameters:
    author: ''
    catch_exceptions: 'True'
    category: '[GRC Hier Blocks]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: arraygeneral
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: arraygeneral
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 8]
    rotation: 0
    state: enabled

blocks:
- name: D
  id: variable
  parameters:
    comment: ''
    value: '0.4'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [829, 62]
    rotation: 0
    state: enabled
- name: N
  id: variable
  parameters:
    comment: ''
    value: Nx*Ny
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [906, 128]
    rotation: 0
    state: enabled
- name: Nx
  id: variable
  parameters:
    comment: ''
    value: '4'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [916, 62]
    rotation: 0
    state: enabled
- name: Ny
  id: variable
  parameters:
    comment: ''
    value: '4'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [834, 129]
    rotation: 0
    state: enabled
- name: Rmax
  id: variable
  parameters:
    comment: ''
    value: N
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1082, 60]
    rotation: 0
    state: enabled
- name: patrones
  id: variable
  parameters:
    comment: ''
    value: None
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [988, 61]
    rotation: 0
    state: enabled
- name: phi_apuntar_gr
  id: variable
  parameters:
    comment: ''
    value: '45'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [945, 198]
    rotation: 0
    state: enabled
- name: po
  id: variable
  parameters:
    comment: ''
    value: ruta3d.receiver_path(128)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [442, 13]
    rotation: 0
    state: enabled
- name: posiciones
  id: variable
  parameters:
    comment: ''
    value: D*np.array([(x,y,0) for x in range(Nx) for y in range(Ny)])
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [978, 131]
    rotation: 0
    state: enabled
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: '32000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [183, 8]
    rotation: 0
    state: enabled
- name: theta_apuntar_gr
  id: variable
  parameters:
    comment: ''
    value: '45'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1066, 197]
    rotation: 0
    state: enabled
- name: w_fases
  id: variable
  parameters:
    comment: ''
    value: antenna_tools.calcularFasesApuntamiento(phi_apuntar_gr*np.pi/180,theta_apuntar_gr*np.pi/180,
      posiciones)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [971, 259]
    rotation: 0
    state: enabled
- name: w_magnitudes
  id: variable
  parameters:
    comment: ''
    value: np.array([1]*N)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [832, 258]
    rotation: 0
    state: enabled
- name: analog_const_source_x_0
  id: analog_const_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    const: '1'
    maxoutbuf: '0'
    minoutbuf: '0'
    type: complex
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [20, 94]
    rotation: 0
    state: true
- name: antenna_tools
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "# Aqui se reunen una serie de funciones que puede ser de utilidad\
      \ en la definicion o configuracion de arreglos de antenas\n\nimport numpy as\
      \ np\n\n# Para apuntar el patron de un arreglo a una direccion phi,theta, usa\
      \ esta funcion de la siguiente\n# manera:\n# * Llama esta funcion por ejemplo\
      \ asi:w_apuntar=calcularFasesApuntamiento(phi,theta,posiciones)\n# * ve a tu\
      \ arreglo y muliplica las exitaciones por w_apuntar\ndef calcularFasesApuntamiento(phi,theta,\
      \ posiciones):\n    normal = np.array((np.cos(phi)*np.sin(theta),np.sin(phi)*np.sin(theta),np.cos(theta)))\n\
      \    fases = -2*np.pi*posiciones@normal\n    return fases\n    \n\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [834, 202]
    rotation: 0
    state: true
- name: blocks_complex_to_mag_0
  id: blocks_complex_to_mag
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [166, 519]
    rotation: 0
    state: enabled
- name: blocks_stream_to_vector_0
  id: blocks_stream_to_vector
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_items: po.L_path
    type: float
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [292, 519]
    rotation: 0
    state: true
- name: blocks_throttle_0_0_0
  id: blocks_throttle
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    ignoretag: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_second: samp_rate
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [508, 137]
    rotation: 0
    state: enabled
- name: blocks_vector_source_x_0
  id: blocks_vector_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    repeat: 'False'
    tags: '[]'
    type: float
    vector: po.phi_path()
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [23, 142]
    rotation: 0
    state: enabled
- name: blocks_vector_source_x_0_0
  id: blocks_vector_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    repeat: 'False'
    tags: '[]'
    type: float
    vector: po.theta_path()
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [27, 217]
    rotation: 0
    state: enabled
- name: blocks_vector_to_stream_0
  id: blocks_vector_to_stream
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_items: po.L_path
    type: float
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [424, 520]
    rotation: 0
    state: true
- name: epy_block_0
  id: epy_block
  parameters:
    _source_code: "\nimport numpy as np\nfrom gnuradio import gr\n\n\nclass blk(gr.sync_block):\
      \  # other base classes are basic_block, decim_block, interp_block\n    \"\"\
      \"Hecho por Homero Ortega Boada y Fernando Alberto Miranda Binomi.\n   Arreglo\
      \ tridimensional de fuentes puntuales\n        \n           @param posiciones\
      \ matriz real n*3 cuyos vectores fila son las posiciones x,y,z de las fuentes\
      \ del arreglo\n           @param excitaciones vector complejo de n elementos\
      \ representando la amplitud y fase de excitaci\xF3n de cada fuente del arreglo\
      \ \n    \"\"\"\n\n    def __init__(self, posiciones=0,excitaciones=1, patrones=None):\
      \  \n        gr.sync_block.__init__(\n            self,\n            name='e_array-general_cc',\
      \   \n            in_sig=[np.complex64, np.float32, np.float32],\n         \
      \   out_sig=[np.complex64]\n        )\n        self.posiciones = posiciones\n\
      \        self.excitaciones = excitaciones\n        if patrones is not None:\n\
      \            self.patrones = patrones\n        else:\n            self.patrones\
      \ = [lambda phi,theta: 1]\n        \n    def _campo_dirUnica(self,phi_i,theta_i):\n\
      \        normal = np.array((np.cos(phi_i)*np.sin(theta_i),np.sin(phi_i)*np.sin(theta_i),np.cos(theta_i)))\n\
      \        fases = 2*np.pi*self.posiciones@normal\n        if len(self.patrones)\
      \ == 1:\n            patronAntena = self.patrones[0](phi_i,theta_i)\n      \
      \      return patronAntena*sum(self.excitaciones*np.exp(1j*fases))\n       \
      \ else:\n            patronesAntenas = np.array([g_i(phi_i,theta_i) for g_i\
      \ in self.patrones])\n            return sum(self.excitaciones*patronesAntenas*np.exp(1j*fases))\n\
      \n    def _densidadPotencia_dirUnica(self,phi_i,theta_i):\n        return (np.abs(self._campo_dirUnica(phi_i,theta_i))**2)/(2*120*np.pi)\n\
      \    def _potenciaMedia(self):\n        # Los primeros l\xEDmites de integraci\xF3\
      n corresponden a la segunda variable de la funci\xF3n integrando!!\n       \
      \ return integrate.dblquad(lambda phi,theta: self._densidadPotencia_dirUnica(phi,theta)*np.sin(theta)\n\
      \                                 ,0,np.pi,-np.pi,np.pi)[0]/(4*np.pi)\n    def\
      \ directividad(self,phi,theta):\n        promedio=self._potenciaMedia()\n  \
      \      def directividad_dirUnica(phi_i,theta_i):\n            return self._densidadPotencia_dirUnica(phi_i,theta_i)/promedio\n\
      \        \n        directividad_vec = np.vectorize(directividad_dirUnica)\n\
      \        return directividad_vec(phi,theta)\n    \n    def campo(self,phi,theta):\n\
      \        campo_vec = np.vectorize(self._campo_dirUnica)\n\n        return campo_vec(phi,theta)\n\
      \        \n    def work(self, input_items, output_items):\n        s=input_items[0]\n\
      \        theta=input_items[2]\n        phi=input_items[1]\n        e=self.campo(phi,theta)\n\
      \        \n        output_items[0][:] = self.campo(phi,theta)\n        return\
      \ len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    excitaciones: w_magnitudes*np.exp(1j*w_fases)
    maxoutbuf: '0'
    minoutbuf: '0'
    patrones: patrones
    posiciones: posiciones
  states:
    _io_cache: "('e_array-general_cc', 'blk', [('posiciones', '0'), ('excitaciones',\
      \ '1'), ('patrones', 'None')], [('0', 'complex', 1), ('1', 'float', 1), ('2',\
      \ 'float', 1)], [('0', 'complex', 1)], 'Hecho por Homero Ortega Boada y Fernando\
      \ Alberto Miranda Binomi.\\n   Arreglo tridimensional de fuentes puntuales\\\
      n        \\n           @param posiciones matriz real n*3 cuyos vectores fila\
      \ son las posiciones x,y,z de las fuentes del arreglo\\n           @param excitaciones\
      \ vector complejo de n elementos representando la amplitud y fase de excitaci\xF3\
      n de cada fuente del arreglo \\n    ', ['excitaciones', 'patrones', 'posiciones'])"
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [299, 109]
    rotation: 0
    state: true
- name: epy_block_0_1_0_0
  id: epy_block
  parameters:
    Rmax: Rmax
    _source_code: "from mpl_toolkits import mplot3d\nimport numpy as np\nfrom gnuradio\
      \ import gr\nimport matplotlib.pyplot as plt\n\nclass polar_graf_f(gr.sync_block):\n\
      \    \"\"\"\n    Grafica polar, pero los valores a graficar estan dados por\
      \ la senal de magnitud entrante y el parametro angular theta. Hecho por Homero\
      \ Ortega Boada. Universida Industrial de Santander.\nHecho con el fin de graficar\
      \ cosas comos patron de radiacion de una antena, aunque inicialmente se inspir\xF3\
      \ en el visor de constelaciones. Rmax sirve para definir los limites de la grafica\"\
      \"\"\n    def __init__(self,samp_rate=32000, Rmax=8):\n        gr.sync_block.__init__(self,\n\
      \            name=\"e_polar_graf_3d_p_f\",\n            in_sig=[np.float32]*3,\n\
      \            out_sig=None)\n\n        #########################################\n\
      \        ##        Parametros                   ##\n        #########################################\n\
      \        self.Tsamp=1./samp_rate\n        self.Rmax=Rmax\n        self.contador=0\n\
      \        #self.fig=0\n        #self.ax=0\n\n    # Canvas grafica la plantilla\
      \ sobre la que se posecionara la grafica 3d\n    def canvas_3d(self, Rmax, nombre):\n\
      \        fig=plt.figure()\n        ax=fig.add_subplot(111, projection='3d')\n\
      \        ax.set_xlim(-Rmax,Rmax)\n        ax.set_ylim(-Rmax,Rmax)\n        ax.set_zlim(-Rmax,Rmax)\n\
      \        ax.set_xlabel('x')\n        ax.set_ylabel('y')\n        ax.set_zlabel('z')\n\
      \        ax.set_title(nombre)\n        return ax\n\n    # Traduccion de coordenadas\
      \ esfericas a cartecianas\n    def esferica2cartesiana(self,phi,theta,R):\n\
      \        x = R * np.cos(phi) * np.sin(theta)\n        y = R * np.sin(phi) *\
      \ np.sin(theta)\n        z = R * np.cos(theta)\n        return(x,y,z)      \
      \                             \n\n    def work(self, input_items, output_items):\n\
      \        R_path=input_items[0]\n        theta_path=input_items[2]\n        phi_path=input_items[1]\n\
      \        x,y,z=self.esferica2cartesiana(phi_path,theta_path,R_path)\n      \
      \  \n        if self.contador == 0:\n           self.contador=1\n          \
      \ ax=self.canvas_3d(self.Rmax, 'Patron 3d')\n               \n        ax.plot(x,y,z,\
      \ color=\"blue\")\n        #ax.scatter(x,y,z, c='y', marker='o')\n        plt.pause(self.Tsamp)\n\
      \        #plt.show()\n        #plt.clf() # esto limpia la grafica\n        return\
      \ len(input_items[0])\n"
    affinity: ''
    alias: yoo
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    samp_rate: samp_rate
  states:
    _io_cache: "('e_polar_graf_3d_p_f', 'polar_graf_f', [('samp_rate', '32000'), ('Rmax',\
      \ '8')], [('0', 'float', 1), ('1', 'float', 1), ('2', 'float', 1)], [], '\\\
      n    Grafica polar, pero los valores a graficar estan dados por la senal de\
      \ magnitud entrante y el parametro angular theta. Hecho por Homero Ortega Boada.\
      \ Universida Industrial de Santander.\\nHecho con el fin de graficar cosas comos\
      \ patron de radiacion de una antena, aunque inicialmente se inspir\xF3 en el\
      \ visor de constelaciones. Rmax sirve para definir los limites de la grafica',\
      \ ['Rmax'])"
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [392, 576]
    rotation: 0
    state: disabled
- name: epy_block_0_1_0_0_0
  id: epy_block
  parameters:
    Rmax: Rmax
    _source_code: "from mpl_toolkits import mplot3d\nimport numpy as np\nfrom gnuradio\
      \ import gr\nimport matplotlib.pyplot as plt\n\nclass polar_graf_f(gr.sync_block):\n\
      \    \"\"\"\nHecho por Homero Ortega Boada. Universidad Industrial de Santander.\n\
      Permite hacer una grafica polar con coordenadas esfericas como es el caso del\
      \ patron de radaicacion de un arreglo de antenas. Las graficas las hacemos con\
      \ herramientas externas a GNU Radio ya que al momento no sabiamos como hacerlo\
      \ de otra manera. Los parametros de entrada son:\n\n* samp_rate: es la frecuencia\
      \ de muestreo en Hz que nunca falta en GNURadio. Influye en la velocidad de\
      \ la grafica, supuestamente se los valores de medicion del  campo llegan con\
      \ esa rata\n* Rmax sirve para definir los limites de la grafica, se supone que\
      \ es el m\xE1ximo valor que puede llegar a tomar el campo en magnitud\n* phi:\
      \ son los valores unicos usados en la grafica para phi. Usualmente phi es un\
      \ vector de valores entre 0 y 2pi con un cierto paso angular\ntheta: son los\
      \ valores unicos usados en la grafica. Usualmente phi es un vector de valores\
      \ entre 0 y pi con el mismo paso angular que phi. De manera que este vector\
      \ tiene 2 veces menos valores que phi\n* La senal que entra al bloque corresponde\
      \ a las mediciones de campo realizadas  para todos los posibles ubicaciones\
      \ angulares que se puede lograr con las combinaciones de phi y theta\n\nNota:\
      \ Por ahora no hemos pretendido que el patron se pueda redibujar en tiempo real\
      \ para nuevas situaciones. Ppor ejemplo, que si en cierto momento cambia la\
      \ alimentacion de los elementos de radiacion que entonces el patron se redibuje\
      \ adotando la nueva forma. Si queremos lograr eso, es posible que haya que hacer\
      \ unas ligeras modidificaciones a la funcione que grafica, para que, cada vez\
      \ que dibuje un nuevo patron previamente borre el anterior. Quiza tambien haya\
      \ que quitar el plt.show() \n\nRetos para mejorar: es mas natural que el bloque\
      \ pueda identifcar phi y theta a partir de las senals que aporta la ruta, es\
      \ decir, usando las mismas senales que usa el bloque e_polar_graf_3d_p_f\n\"\
      \"\"\n    def __init__(self,samp_rate=32000, Rmax=8,phi=0,theta=0 ):\n     \
      \   gr.sync_block.__init__(self,\n            name=\"e_polar_graf_3d_f\",\n\
      \            in_sig=[np.float32],\n            out_sig=None)\n            \n\
      \        # Parametros                   \n        self.Tsamp=1./samp_rate\n\
      \        self.Rmax=Rmax\n        self.contador=0\n        self.phi=phi\n   \
      \     self.theta=theta\n        \n    # Canvas grafica la plantilla sobre la\
      \ que se posicionara la grafica 3d\n    def canvas_3d(self, Rmax, nombre):\n\
      \        fig=plt.figure()\n        ax2=fig.add_subplot(111, projection='3d')\n\
      \        ax2.set_xlim(-Rmax,Rmax)\n        ax2.set_ylim(-Rmax,Rmax)\n      \
      \  ax2.set_zlim(-Rmax,Rmax)\n        ax2.set_xlabel('x')\n        ax2.set_ylabel('y')\n\
      \        ax2.set_zlabel('z')\n        ax2.set_title(nombre)\n        return\
      \ ax2\n\n    # Traduccion de coordenadas esfericas a cartecianas\n    def esferica2cartesiana(self,phi,theta,R):\n\
      \        x = R * np.cos(phi) * np.sin(theta)\n        y = R * np.sin(phi) *\
      \ np.sin(theta)\n        z = R * np.cos(theta)\n        return(x,y,z)      \
      \                             \n\n    def work(self, input_items, output_items):\n\
      \        # Inicialmente se deben crear 3 matrices de NringsxNang:\n        #\
      \ * PHI\n        # * THETA\n        # * R\n        # Nrings: es el numero de\
      \ filasy equivale al numero de anillos en la graf 3d\n        # Nang: es el\
      \ numero de columnas y a la vez de puntos por cada anillo de la graf 3d\n  \
      \      R_path=input_items[0] \n        Nang=len(self.phi) \n        Nrings=len(self.theta)\n\
      \        PHI,THETA=np.meshgrid(self.phi,self.theta)\n        R=R_path.reshape(Nrings,Nang)\n\
      \        X,Y,Z=self.esferica2cartesiana(PHI,THETA,R)\n        \n        # El\
      \ if  es porque el canva solo se dibuna una vez y no hemos logrado que se haga\n\
      \        # dentro del constructor.\n        if self.contador == 0:\n       \
      \    self.contador=1\n           ax2=self.canvas_3d(self.Rmax, 'Patron 3d')\n\
      \n        # Finalmente se ordena la grafica de los valores en X,Y,Z       \n\
      \        #ax2.plot_wireframe(X,Y,Z)\n        #plt.clr()\n        ax2.plot_surface(X,Y,Z,cmap=\"\
      coolwarm\")\n        plt.pause(self.Tsamp)\n        plt.show()\n        return\
      \ len(input_items[0])\n"
    affinity: ''
    alias: 3d_f
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    phi: po.phi
    samp_rate: samp_rate
    theta: po.theta
  states:
    _io_cache: "('e_polar_graf_3d_f', 'polar_graf_f', [('samp_rate', '32000'), ('Rmax',\
      \ '8'), ('phi', '0'), ('theta', '0')], [('0', 'float', 1)], [], '\\nHecho por\
      \ Homero Ortega Boada. Universidad Industrial de Santander.\\nPermite hacer\
      \ una grafica polar con coordenadas esfericas como es el caso del patron de\
      \ radaicacion de un arreglo de antenas. Las graficas las hacemos con herramientas\
      \ externas a GNU Radio ya que al momento no sabiamos como hacerlo de otra manera.\
      \ Los parametros de entrada son:\\n\\n* samp_rate: es la frecuencia de muestreo\
      \ en Hz que nunca falta en GNURadio. Influye en la velocidad de la grafica,\
      \ supuestamente se los valores de medicion del  campo llegan con esa rata\\\
      n* Rmax sirve para definir los limites de la grafica, se supone que es el m\xE1\
      ximo valor que puede llegar a tomar el campo en magnitud\\n* phi: son los valores\
      \ unicos usados en la grafica para phi. Usualmente phi es un vector de valores\
      \ entre 0 y 2pi con un cierto paso angular\\ntheta: son los valores unicos usados\
      \ en la grafica. Usualmente phi es un vector de valores entre 0 y pi con el\
      \ mismo paso angular que phi. De manera que este vector tiene 2 veces menos\
      \ valores que phi\\n* La senal que entra al bloque corresponde a las mediciones\
      \ de campo realizadas  para todos los posibles ubicaciones angulares que se\
      \ puede lograr con las combinaciones de phi y theta\\n\\nNota: Por ahora no\
      \ hemos pretendido que el patron se pueda redibujar en tiempo real para nuevas\
      \ situaciones. Ppor ejemplo, que si en cierto momento cambia la alimentacion\
      \ de los elementos de radiacion que entonces el patron se redibuje adotando\
      \ la nueva forma. Si queremos lograr eso, es posible que haya que hacer unas\
      \ ligeras modidificaciones a la funcione que grafica, para que, cada vez que\
      \ dibuje un nuevo patron previamente borre el anterior. Quiza tambien haya que\
      \ quitar el plt.show() \\n\\nRetos para mejorar: es mas natural que el bloque\
      \ pueda identifcar phi y theta a partir de las senals que aporta la ruta, es\
      \ decir, usando las mismas senales que usa el bloque e_polar_graf_3d_p_f\\n',\
      \ ['Rmax', 'phi', 'theta'])"
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [631, 552]
    rotation: 0
    state: enabled
- name: import_0
  id: import
  parameters:
    alias: ''
    comment: ''
    imports: import numpy as np
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [619, 13]
    rotation: 0
    state: true
- name: qtgui_number_sink_0
  id: qtgui_number_sink
  parameters:
    affinity: ''
    alias: ''
    autoscale: 'False'
    avg: '0'
    color1: ("black", "black")
    color10: ("black", "black")
    color2: ("black", "black")
    color3: ("black", "black")
    color4: ("black", "black")
    color5: ("black", "black")
    color6: ("black", "black")
    color7: ("black", "black")
    color8: ("black", "black")
    color9: ("black", "black")
    comment: ''
    factor1: '1'
    factor10: '1'
    factor2: '1'
    factor3: '1'
    factor4: '1'
    factor5: '1'
    factor6: '1'
    factor7: '1'
    factor8: '1'
    factor9: '1'
    graph_type: qtgui.NUM_GRAPH_HORIZ
    gui_hint: 2,0,1,1
    label1: Campo E
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    max: Rmax
    min: '0'
    name: '"Campo E"'
    nconnections: '1'
    type: float
    unit1: ''
    unit10: ''
    unit2: ''
    unit3: ''
    unit4: ''
    unit5: ''
    unit6: ''
    unit7: ''
    unit8: ''
    unit9: ''
    update_time: '0.10'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [626, 456]
    rotation: 0
    state: enabled
- name: ruta3d
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "# Lo que hace este programa es lo siguiente:\n# * calcula todos\
      \ los valores angulares en los que un\n# receptor se debe ubicar con el fin\
      \ de poder \n# medir todos los valores de campo y con todo eso\n# poder graficar\
      \ el patron de radiacion en 3d\n# * A diferencia de lo que se hace en la programacion\n\
      # tradicional, donde se dice que phi tiene unos valore\n# entre 0 y 360 grados\
      \ y theta entre 0 y 180, aqui, por usar\n# programacion de tiempo real hay que\
      \ imaginar que tomamos un dron\n# y le pre-programos toda la ruta que hay que\
      \ seguir para \n# sea posible obtener todos los datos del patron de radiacion\n\
      # de un arreglo\n#\n# Como se usa:\n# * supongamos que Ud desea que la ruta\
      \ se haga que tenga Nang=128 puntos angulares por cada anilo\n# Entonces crea\
      \ el objeto po=receiver_path(128) . Nota Nang debe ser tipo 2 a la m\n# * puede\
      \ obtener los valores unicos de phi como po.phi\n# * los de theta como po.theta\n\
      # * los valores que phi para toda la ruta como po.phi_path()\n# * los valores\
      \ que theta para toda la ruta como po.theta_path()\n# * tambien se puede acceder\
      \ al numero de anillos que la grafica\n# tendra en el eje z como po.Nrings\n\
      # * igualmente, el numero de puntos de cada anillo po.Nang\n# * y el numero\
      \ de puntos de toda la ruta po.L_path\n\nimport numpy as np\n\ndef zerooh(x,Sps):\n\
      \    Lx=len(x)\n    g=np.array([x[0]]*Sps)\n    for i in range(1,Lx):\n    \
      \    g=np.concatenate((g,np.array([x[i]]*Sps)))\n    return g\n\nclass receiver_path(object):\n\
      \    def __init__(self, Nang):\n        self.Nang=Nang\n        self.Nrings=int(Nang/2)\n\
      \        self.pasoAngular=360/Nang\n        self.L_path=Nang*self.Nrings\n \
      \       self.phi=np.linspace(0,360-self.pasoAngular,Nang)*np.pi/180\n      \
      \  self.theta=np.linspace(0,180-self.pasoAngular,self.Nrings)*np.pi/180\n  \
      \    \n    # calculo de los valores de phi para todo el recorrido          \
      \  \n    def phi_path(self,):\n        return(np.tile(self.phi, self.Nrings))\n\
      \n    # calculo de los valores de theta para todo el recorrido\n    def theta_path(self,):\n\
      \        return(zerooh(self.theta,self.Nang))\n\n\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [326, 13]
    rotation: 0
    state: true
- name: virtual_sink_0
  id: virtual_sink
  parameters:
    alias: ''
    comment: ''
    stream_id: out1
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [656, 253]
    rotation: 270
    state: true
- name: virtual_sink_1
  id: virtual_sink
  parameters:
    alias: ''
    comment: ''
    stream_id: out2
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [296, 270]
    rotation: 270
    state: true
- name: virtual_sink_1_0
  id: virtual_sink
  parameters:
    alias: ''
    comment: ''
    stream_id: out3
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [242, 272]
    rotation: 270
    state: true
- name: virtual_source_0
  id: virtual_source
  parameters:
    alias: ''
    comment: ''
    stream_id: out1
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [54, 515]
    rotation: 0
    state: enabled
- name: virtual_source_1
  id: virtual_source
  parameters:
    alias: ''
    comment: ''
    stream_id: out2
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [47, 595]
    rotation: 0
    state: disabled
- name: virtual_source_1_0
  id: virtual_source
  parameters:
    alias: ''
    comment: ''
    stream_id: out3
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [46, 641]
    rotation: 0
    state: disabled

connections:
- [analog_const_source_x_0, '0', epy_block_0, '0']
- [blocks_complex_to_mag_0, '0', blocks_stream_to_vector_0, '0']
- [blocks_stream_to_vector_0, '0', blocks_vector_to_stream_0, '0']
- [blocks_throttle_0_0_0, '0', virtual_sink_0, '0']
- [blocks_vector_source_x_0, '0', epy_block_0, '1']
- [blocks_vector_source_x_0, '0', virtual_sink_1, '0']
- [blocks_vector_source_x_0_0, '0', epy_block_0, '2']
- [blocks_vector_source_x_0_0, '0', virtual_sink_1_0, '0']
- [blocks_vector_to_stream_0, '0', epy_block_0_1_0_0_0, '0']
- [blocks_vector_to_stream_0, '0', qtgui_number_sink_0, '0']
- [epy_block_0, '0', blocks_throttle_0_0_0, '0']
- [virtual_source_0, '0', blocks_complex_to_mag_0, '0']
- [virtual_source_1, '0', epy_block_0_1_0_0, '1']
- [virtual_source_1_0, '0', epy_block_0_1_0_0, '2']

metadata:
  file_format: 1
